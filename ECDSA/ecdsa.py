#!/usr/bin/python

from binascii import hexlify
from hashlib import sha256
import base64
from ecdsa import curves
from ecdsa import SigningKey
from ecdsa.util import sigencode_der
from ecdsa.util import sigdecode_der
from ecdsa.numbertheory import inverse_mod

n = curves.SECP256k1.order

msg1 = 'aaaaa'
sig1 = base64.b64decode('MEUCIC+L3k0aByCTVbSnJQpcUSjoi4S93GGat8uo1WmyQO/kAiEAlprboJJ/k+etngA4FXCtMtAF887l4HUECf0G9BM4pnY=')
sig1 = sigdecode_der(sig1, n)
print "(r1, s1):"
print sig1

msg2 = 'bbbbb'
sig2 = base64.b64decode('MEUCIC+L3k0aByCTVbSnJQpcUSjoi4S93GGat8uo1WmyQO/kAiEArTDUzY1BoJHy+DEuLhdJakeQS3INvsR7C2L92wlf8TM=')
sig2 = sigdecode_der(sig2, n)
print "(r1, s2):"
print sig2

r1 = sig1[0]
s1 = sig1[1]
z1 = int(hexlify(sha256(msg1).digest()), 16)
r2 = sig2[0]
s2 = sig2[1]
z2 = int(hexlify(sha256(msg2).digest()), 16)

if r1 == r2:
    print "\nr1 = r2 - vulnerable ECDSA signature\n"

k = (z1 - z2) * inverse_mod(s1 - s2, n) % n
print "Got k: 0x{:x}\n".format(k)

dA = (s1 * k - z1) * inverse_mod(r1, n) % n
print "Got dA: 0x{:x}\n".format(dA)

sk = SigningKey.from_secret_exponent(dA, curve = curves.SECP256k1, hashfunc = sha256)
print "Signing Key: \n" + sk.to_pem()

#vk = sk.get_verifying_key()
#vk.verify(sig2, msg2, hashfunc=sha256, sigdecode = sigdecode_der)
#print vk.to_pem()

print "Test (r1, s1):"
print sigdecode_der(sk.sign(msg1, k=k, sigencode = sigencode_der, hashfunc = sha256), n)
print

msg3 = 'admin'
sig3 = sk.sign(msg3, k=k, sigencode = sigencode_der, hashfunc = sha256)
print base64.b64encode('%s--%s' % (msg3, sig3))
